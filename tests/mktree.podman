#!/bin/bash
#
# Podman-based mktree backend using an OCI image to build and run RPM.
# Works standalone (outside of a build directory) too.

PROGRAM=$(basename $0)
CMD=$1; shift

FULL_IMG=rpm
BASE_IMG=${FULL_IMG}-base
SNAP_IMG=${FULL_IMG}-snapshot

TREE_DIR=$PWD/mktree.dir
SNAP_DIR=$TREE_DIR/snapshot

if [ $(id -u) != 0 ]; then
    podman unshare $0 $CMD "$@"
    exit
fi

if [ "$PROGRAM" == "mktree" ]; then
    # Running from build directory
    NATIVE=@MKTREE_NATIVE@
    CONTEXT=@CMAKE_SOURCE_DIR@
else
    # Running from source directory
    NATIVE=0
    CONTEXT=..
fi

RESET_MOTD="
To throw away the snapshot and start over, run:

  make reset"

SHELL_MOTD="
Welcome to RPM @CMAKE_PROJECT_VERSION@ container!

This is a container running a minimal version of the host
system in a writable snapshot, with the RPM build installed
and ready to experiment with.

To update the RPM installation with the latest source
changes, re-enter this target.
$RESET_MOTD
"

ATSHELL_MOTD="
Welcome to RPM @CMAKE_PROJECT_VERSION@ Autotest shell!

This is like an interactive test with a writable snapshot
mounted at \$RPMTEST, with full host integration allowing
you to use your native tools to inspect and/or modify the
snapshot.

The shell runs in a user namespace WITHOUT filesystem
isolation so be mindful when using destructive commands.
Treat it like any other shell running on your host.

The usual test commands are available, e.g.

  runroot rpm ...
$RESET_MOTD
"

fix_perm()
{
    chmod -Rf u+rwX $SNAP_DIR rpmtests.dir
}

get_image_id()
{
    podman image inspect --format '{{.Id}}' $1
}

mount_image()
{
    clean_up()
    {
        podman image umount $FULL_IMG >/dev/null
        fix_perm
    }
    trap clean_up EXIT
    RPMTEST=$(podman image mount $FULL_IMG)
}

mount_snapshot()
{
    clean_up()
    {
        snapshot umount
        podman image umount $SNAP_IMG >/dev/null
        fix_perm
    }
    trap clean_up EXIT

    if [ $NATIVE == 1 ]; then
        image=$BASE_IMG
    else
        image=$FULL_IMG
    fi

    if [ ! -d "$SNAP_DIR" ]; then
        podman tag $image $SNAP_IMG
    elif [ "$(get_image_id $SNAP_IMG)" != "$(get_image_id $image)" ]; then
        SHELL_MOTD+="\nNew base image is available, reset to use.\n"
    fi

    RPMTREE=$(podman image mount $SNAP_IMG)
    RPMTEST=$SNAP_DIR/tree
    snapshot mount $SNAP_DIR

    if [ $NATIVE == 1 ]; then
        ./mktree.native build $RPMTEST
    fi
}

source ./snapshot

case $CMD in
    build)
        mkdir -p $TREE_DIR

        if [ $NATIVE == 1 ]; then
            target=base
            image=$BASE_IMG
        else
            target=full
            image=$FULL_IMG
        fi

        # Build (base) image
        podman build --target $target -t $image -f Dockerfile $CONTEXT

        # Finish unless native mode was selected
        if [ $NATIVE == 0 ]; then
            touch $TREE_DIR/full
            exit
        fi

        # Build RPM natively, layer it on top
        name=$(buildah from $image)
        ./mktree.native build $(buildah mount $name)
        {
            buildah rmi $FULL_IMG
            buildah commit -q $name $FULL_IMG
            buildah umount $name
            buildah rm $name
        } >/dev/null
        touch $TREE_DIR/full
    ;;
    check)
        mount_image
        snapshot exec --tmpfs /tmp --bind $PWD /srv --chdir /srv \
                      mktree check "$@"
    ;;
    shell)
        mount_snapshot
        echo -e "$SHELL_MOTD"
        snapshot shell "$@"
    ;;
    atshell)
        set -a
        source ./atlocal
        mount_snapshot
        echo -e "$ATSHELL_MOTD"
        $SHELL
    ;;
    reset)
        podman rmi -i $SNAP_IMG
        rm -rf "$SNAP_DIR"
    ;;
esac
