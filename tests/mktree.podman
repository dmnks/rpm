#!/bin/bash
#
# Podman-based mktree backend using an OCI image to build and run RPM.
# Works standalone (outside of a build directory) too.

PROGRAM=$(basename $0)
CMD=$1; shift

if [ $(id -u) != 0 ]; then
    podman unshare $0 $CMD "$@"
    exit
fi

if [ "$PROGRAM" == "mktree" ]; then
    # Running from build directory
    NATIVE=@MKTREE_NATIVE@
    CONTEXT=@CMAKE_SOURCE_DIR@
else
    # Running from source directory
    NATIVE=OFF
    CONTEXT=..
fi

TREE_DIR=${PWD}/mktree.dir
TAGS_DIR=${TREE_DIR}/tags
SNAP_DIR=${TREE_DIR}/snapshot

IMAGE=rpm
PODMAN_ARGS="-f Dockerfile $CONTEXT"

SHELL_MOTD="
Welcome to RPM @CMAKE_PROJECT_VERSION@ container!

This is a container running a minimal version of the host
system in a writable snapshot, with the RPM build installed
and ready to experiment with.

To update the RPM installation with the latest source
changes, re-enter this target.
"

ATSHELL_MOTD="
Welcome to RPM @CMAKE_PROJECT_VERSION@ Autotest shell!

This is like an interactive test with a writable snapshot
mounted at \$RPMTEST, with full host integration allowing
you to use your native tools to inspect and/or modify the
snapshot.

The shell runs in a user namespace WITHOUT filesystem
isolation so be mindful when using destructive commands.
Treat it like any other shell running on your host.

The usual test commands are available, e.g.

  runroot rpm ...
"

print_motd()
{
    case $CMD in
        shell) echo "$SHELL_MOTD" ;;
        atshell) echo "$ATSHELL_MOTD" ;;
    esac
    echo "To throw away the snapshot and start over, run:"
    echo
    echo "  make reset"
    echo
    if [ $NEW_IMAGE == 1 ]; then
        echo "Warning: New image is available, reset to use it."
    fi
}

# Manage local tags for Podman images
tag()
{
    # Handle options
    case $1 in
        # Delete tag
        -d) rm -f $TAGS_DIR/$2; return ;;
        # Tag existence check
        -e) test -f $TAGS_DIR/$2; return ;;
        # Image existence check
        -i) $(tag -e $2) && podman image exists $(tag $2); return ;;
    esac

    # Handle load/save
    if [ $# == 1 ]; then
        # Load tag
        cat $TAGS_DIR/$1
    else
        # Save tag
        mkdir -p $TAGS_DIR
        podman image inspect --format '{{.Id}}' $1 > $TAGS_DIR/$2
    fi
}

fix_perm()
{
    chmod -Rf u+rwX $SNAP_DIR rpmtests.dir
}

mount_image()
{
    tag -i full || $0 build

    clean_up()
    {
        podman image umount $(tag full) >/dev/null
        fix_perm
    }
    trap clean_up EXIT

    RPMTEST=$(podman image mount $(tag full))
}

mount_snapshot()
{
    if [ $NATIVE == ON ]; then
        tag=base
    else
        tag=full
    fi

    tag -i $tag || $0 build

    NEW_IMAGE=0
    if ! tag -e snap; then
        tag $(tag $tag) snap
    elif ! $(tag -i snap); then
        {
            echo
            echo "Error: Image not found, fix with:"
            echo
            echo "  make reset"
            echo
        } >&2
        exit 1
    elif [ "$(tag snap)" != "$(tag $tag)" ]; then
        NEW_IMAGE=1
    fi

    clean_up()
    {
        snapshot umount
        podman image umount $(tag snap) >/dev/null
        fix_perm
    }
    trap clean_up EXIT

    RPMTREE=$(podman image mount $(tag snap))
    RPMTEST=$SNAP_DIR/tree
    snapshot mount $SNAP_DIR

    [ $NATIVE == ON ] && ./mktree.native build $RPMTEST
}

source ./snapshot

case $CMD in
    build)
        # Build base image
        podman build --target base -t $IMAGE/base $PODMAN_ARGS
        tag $IMAGE/base base

        # Force non-native mode?
        [ "$1" == "--full" ] && NATIVE=OFF

        # Build full image
        tag -i full && podman rmi $(tag full)
        if [ $NATIVE == ON ]; then
            # Native RPM build
            name=$(buildah from $IMAGE/base)
            ./mktree.native build $(buildah mount $name)
            buildah commit -q --rm $name $IMAGE
        else
            # Containerized RPM build
            podman build --target full -t $IMAGE $PODMAN_ARGS
        fi
        tag $IMAGE full

        # Signal change to build system
        mkdir -p $TREE_DIR
        touch $TREE_DIR
    ;;
    check)
        mount_image
        snapshot exec --tmpfs /tmp --bind $PWD /srv --chdir /srv \
                      mktree check "$@"
    ;;
    shell)
        mount_snapshot
        print_motd
        snapshot shell "$@"
    ;;
    atshell)
        set -a
        source ./atlocal
        mount_snapshot
        print_motd
        $SHELL
    ;;
    reset)
        tag -d snap
        rm -rf "$SNAP_DIR"
    ;;
    refresh)
    ;;
esac
