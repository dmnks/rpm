#!/bin/bash
#
# Podman-based mktree backend using an OCI image to build and run RPM.
# Works standalone (outside of a build directory) too.

PROGRAM=$(basename $0)
CMD=$1; shift

TREE_DIR=${PWD}/mktree.dir
SNAP_DIR=${TREE_DIR}/snapshot

FULL_IMG=rpm
BASE_IMG=rpm-base
SNAP_IMG=rpm-base

if [ $(id -u) != 0 ]; then
    podman unshare $0 $CMD "$@"
    exit
fi

if [ "$PROGRAM" == "mktree" ]; then
    # Running from build directory
    NATIVE=@MKTREE_NATIVE@
    CONTEXT=@CMAKE_SOURCE_DIR@
else
    # Running from source directory
    NATIVE=0
    CONTEXT=..
fi

SHELL_MOTD="
Welcome to RPM @CMAKE_PROJECT_VERSION@ container!

This is a container running a minimal version of the host
system in a writable snapshot, with the RPM build installed
and ready to experiment with.

To update the RPM installation with the latest source
changes, re-enter this target.
"

ATSHELL_MOTD="
Welcome to RPM @CMAKE_PROJECT_VERSION@ Autotest shell!

This is like an interactive test with a writable snapshot
mounted at \$RPMTEST, with full host integration allowing
you to use your native tools to inspect and/or modify the
snapshot.

The shell runs in a user namespace WITHOUT filesystem
isolation so be mindful when using destructive commands.
Treat it like any other shell running on your host.

The usual test commands are available, e.g.

  runroot rpm ...
"

print_motd()
{
    case $CMD in
        shell) echo "$SHELL_MOTD" ;;
        atshell) echo "$ATSHELL_MOTD" ;;
    esac
    echo "To throw away the snapshot and start over, run:"
    echo
    echo "  make reset"
    echo
    if [ $NEW_IMAGE == 1 ]; then
        echo "## --------------------------------------- ##"
        echo "## Image has been rebuilt, reset to apply. ##"
        echo "## --------------------------------------- ##"
        echo
    fi
}

silent()
{
    if [ "$1" == "-f" ]; then
        shift
        "$@" >/dev/null 2>&1
    else
        "$@" >/dev/null
    fi
}

fix_perm()
{
    chmod -Rf u+rwX $SNAP_DIR rpmtests.dir
}

mount_image()
{
    clean_up()
    {
        silent podman image umount $FULL_IMG
        fix_perm
    }
    trap clean_up EXIT
    RPMTEST=$(podman image mount $FULL_IMG)
}

mount_snapshot()
{
    clean_up()
    {
        snapshot umount
        silent podman image umount $SNAP_IMG
        fix_perm
    }
    trap clean_up EXIT

    # tag_exists snap || tag_add $BASE_TAG snap
    # SNAP_TAG=$(tag_get snap)

    NEW_IMAGE=0
    # if [ "$SNAP_TAG" == "$BASE_TAG" ]; then
    #     NEW_IMAGE=0
    # else
    #     NEW_IMAGE=1
    # fi

    RPMTREE=$(podman image mount $SNAP_IMG)
    RPMTEST=$SNAP_DIR/tree
    snapshot mount $SNAP_DIR

    [ $NATIVE == 1 ] && ./mktree.native build $RPMTEST
}

source ./snapshot

case $CMD in
    build)
        if [ "$1" == "--full" ]; then
            NATIVE=0
            shift
        fi

        if [ $NATIVE == 1 ]; then
            target=base
            image=$BASE_IMG
        else
            target=full
            image=$FULL_IMG
        fi

        # Build base image
        podman build --target $target -t $image -f Dockerfile $CONTEXT

        [ "$1" == "--base" ] && exit 0

        # Promote to full image and finish unless in native mode
        if [ $NATIVE == 0 ]; then
            podman tag $image $FULL_IMG
            exit 0
        fi

        # Build RPM natively, layer it on top
        name=$(buildah from $image)
        trap "silent buildah umount $name; silent buildah rm $name" EXIT
        ./mktree.native build $(buildah mount $name)
        silent -f buildah rmi $FULL_IMG
        silent buildah commit -q $name $FULL_IMG
    ;;
    check)
        mount_image
        snapshot exec --tmpfs /tmp --bind $PWD /srv --chdir /srv \
                      mktree check "$@"
    ;;
    shell)
        mount_snapshot
        print_motd
        snapshot shell "$@"
    ;;
    atshell)
        set -a
        source ./atlocal
        mount_snapshot
        print_motd
        $SHELL
    ;;
    reset)
        rm -rf "$SNAP_DIR"
    ;;
esac
